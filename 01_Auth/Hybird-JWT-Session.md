
## 1. 개요
- JWT는 각 요청마다 토큰 자체를 검증하여 인증을 수행할 수 있는 Stateless 인증 방식을 제공하므로, 프론트엔드와 백엔드가 분리된 API 서버 구조에서 단순하고 확장성 있는 인증 흐름을 구성할 수 있다는 장점이 있습니다. 본 프로젝트에서도 이러한 JWT의 특성을 기반으로 인증 구조를 설계하였으나, 자동 로그아웃 처리, 권한 변경 즉시 반영, 강제 로그아웃과 같은 실제 서비스 요구사항을 적용하는 과정에서 완전한 Stateless 구조만으로는 한계가 존재하였습니다. 이에 따라 서버 주도로 관리되어야 하는 상태 정보에 한해 Redis를 결합한 하이브리드 방식을 적용하였으며, JWT는 인증 정보 전달 및 검증 수단으로, Redis는 세션 상태 및 권한 관리를 담당하는 구조로 구현하였습니다.
---

## 2. 요구사항
- **세션 타임아웃 자동 처리**
	- 사용자가 일정 시간 동안 API 요청이 없으면 자동 로그아웃
	- 정상 황동(API 호출)이 있을 경우 세션 시간 연장

- **권한 변경 시 즉시 세션 무효화**
	- 관리자가 사용자 권한을 변경하면 해당 사용자 로그아웃 처리(세션 무효화)

- **강제 로그아웃 / 탈퇴 처리**
	- 관리자가 사용자를 강제 로그아웃, 탈퇴 처리하면 해당 사용자 로그아웃 처리(세션 무효화)
---

## 3. 전체 아키텍처 구조
프론트엔드에서 API 요청 시, 인증에 필요한 쿠키(JWT, SessionExpires 등)는
`credentials: include` 설정을 통해 함께 전송됩니다.

백엔드에서는 Spring Security Filter 단계에서 요청을 가로채
JWT 토큰 존재 여부를 확인하고 인증 흐름을 시작합니다.

우선 Redis 저장소의 상태를 확인하여 정상 동작 여부를 판단합니다.
Redis가 정상 상태인 경우, JWT Payload에 포함된 SID를 기준으로
Redis에 저장된 세션 정보를 조회하여 사용자 유효성을 검증합니다.

유효한 사용자로 확인되면,
Redis 세션과 브라우저의 SessionExpires 쿠키를 기준으로
세션 만료 시간이 슬라이딩 방식으로 연장되며,
Redis에서 조회된 사용자 정보가 SecurityContext에 설정됩니다.

반대로 Redis가 비정상 상태이거나,
SID에 해당하는 세션 정보가 존재하지 않는 경우에는
인증된 사용자로 처리하지 않고 Guest 권한으로 분기됩니다.
이때 Redis 장애 상황에서는 JWT의 만료 시간(EXP)을 기준으로
제한적인 인증 흐름(Degrade Mode)이 적용됩니다.

또한 Access Token은 만료 시간이 짧기 때문에,
요청 시점에 Access Token이 없거나(미보유) 만료(Expired)된 경우가 존재합니다.
이 경우 인증 필터는 Refresh Token 기반의 Access 재발급을 먼저 시도합니다.

재발급은 Redis가 정상 상태이고, Refresh Token이 유효하며,
Refresh Token의 sid로 조회한 Redis 세션이 존재하는 경우에만 성공합니다.
성공 시 새로운 Access Token 쿠키와 SessionExpires 쿠키를 갱신하고
인증 사용자로 SecurityContext를 구성합니다.
실패 시에는 Guest로 처리됩니다.

### 3.1 Access Token 기반 인증 흐름 다이어그램
→ [[Auth-Architecture-Access]]

### 3.2 Refresh Token 기반 Access 재발급 다이어그램
→ [[Auth-Architecture-Refresh]]

---
