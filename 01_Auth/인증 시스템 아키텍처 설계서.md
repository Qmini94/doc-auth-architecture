## 1. 개요
JWT(JSON Web Token)는 Stateless 특성을 통해 분산 환경에서의 확장성을 제공하나, 토큰 자체의 독립성으로 인해 강제 로그아웃이나 권한 변경의 즉시 반영과 같은 서버 주도의 세션 제어가 불가능한 구조적 한계가 존재합니다.

본 프로젝트는 이러한 한계를 보완하기 위해 JWT와 Redis를 결합한 하이브리드 인증 아키텍처를 설계하였습니다. JWT는 클라이언트와 서버 간의 인증 정보 전달 및 무결성 검증을 담당하며, Redis는 세션 상태(State) 및 권한 생명주기를 관리하여 보안성과 편의성을 동시에 확보하는 것을 목적으로 합니다. 이를 통해 Stateless 아키텍처의 이점을 유지하면서도 엔터프라이즈 환경에서 요구되는 세밀한 세션 제어 기능을 구현하였습니다. 본 설계는 슬라이딩 방식, 강제 로그아웃, 권한 즉시 변경 반영 등 여러 대안을 검토한 결과, 토큰 검증 비용, 세션 제어 범위, 장애 시 가용성 측면에서 가장 균형 잡힌 구조로 생각되어 채택하였습니다.

---
## 2. 기능 요구사항
본 시스템은 기본적인 인증 기능 외에 운영 안정성과 보안성을 확보하기 위해 다음과 같은 세부 요구사항을 충족하도록 설계되었습니다.

**세션 타임아웃 자동 관리**
사용자의 활동(API 요청)이 감지될 때마다 세션 만료 시간을 자동으로 연장하여 끊김 없는 사용자 경험을 제공합니다. 반면, 일정 시간 동안 요청이 발생하지 않을 경우 자동으로 로그아웃 처리하여 보안 리스크를 최소화합니다.

**권한 변경의 실시간성 보장**
관리자에 의한 사용자 권한 변경이 발생할 경우, 다음 요청 시 즉각적으로 세션을 무효화하여 변경 사항이 지체 없이 시스템에 반영되도록 합니다. 이는 기존 JWT 단독 사용 시 발생하는 권한 불일치 시간을 제거합니다.

**강제 로그아웃 및 계정 잠금**
보안 침해 사고나 운영상의 필요에 의해 특정 사용자의 접근을 즉시 차단해야 할 경우, 서버 측에서 해당 사용자의 세션을 강제로 종료할 수 있는 제어권을 확보합니다.

---
## 3. 아키텍처 및 인증 흐름
클라이언트는 API 요청 시 브라우저의 보안 정책에 따라 JWT 및 세션 쿠키를 포함하여 전송합니다. 백엔드의 Spring Security Filter는 요청을 가로채어 Redis 상태에 따라 차별화된 인증 로직을 수행합니다.

### 3.1 정상 모드
Redis가 정상적으로 동작하는 경우, 인증 필터는 JWT Payload에 포함된 SID(Session ID)를 기준으로 Redis에 저장된 세션 정보를 조회합니다.  
조회된 세션이 유효한 경우, 해당 요청은 인증된 사용자로 처리되며 Redis Session의 TTL은 슬라이딩 방식으로 갱신됩니다. 이후 사용자 인증 정보는 SecurityContext에 설정되어 요청 처리가 진행됩니다.

### 3.2 장애 대응 모드
Redis 접속 불가와 같은 인프라 장애가 발생한 경우, 시스템은 가용성 유지를 위해 장애 대응 모드로 전환됩니다.  
이 경우 서버 측 세션 검증은 수행하지 않으며, JWT 자체의 서명 검증과 만료 시간(exp)을 기준으로 제한적인 인증만을 수행합니다.

장애 대응 모드에서는 보안 수준을 유지하기 위해 모든 사용자를 최소 권한으로 처리하며, 관리 기능이나 민감한 권한이 요구되는 요청은 제한됩니다. Redis 장애가 해소되면 인증 흐름은 자동으로 정상 모드로 복귀합니다.

### 3.3 토큰 재발급 프로세스
Access Token이 만료된 경우, 클라이언트는 Refresh Token을 통해 Access Token 재발급을 요청합니다.  
재발급은 Redis가 정상 상태이며, Refresh Token과 매핑된 서버 측 세션 정보가 유효한 경우에만 허용됩니다.

이를 통해 탈취된 Refresh Token 단독 사용으로 인한 무제한 접근을 방지하고, 서버 주도의 세션 생명주기 제어가 가능하도록 하였습니다.
- [01_네트워크_정의_및_역사](../01_네트워크_소개/01_네트워크_정의_및_역사.md)
### Access Token 기반 인증 흐름 다이어그램
→ [Auth-Architecture-Access](Auth-Architecture-Access.md)

### Refresh Token 기반 Access 재발급 다이어그램
→ [Auth-Architecture-Refresh](Auth-Architecture-Refresh.md)

---
## 4. 핵심 컴포넌트 명세
인증 아키텍처를 구성하는 핵심 컴포넌트들의 역할과 구조를 정의합니다.
각 컴포넌트는 슬라이딩 세션 관리, 다중 로그인 환경, 강제 로그아웃, 장애 대응이라는 요구사항을 충족하기 위해 상호 보완적으로 설계되었습니다.

### 4.1 Access Token(JWT)
Access Token은 클라이언트가 보유하며 API 요청 시 신원 증명을 위해 사용됩니다. 토큰 탈취 시 피해를 최소화하기 위해 짧은 만료 시간(15분)을 가지며, 브라우저 환경에서는 HttpOnly 쿠키로 관리하여  XSS 공격에 대한 노출을 최소화합니다.

| 항목        | 구분      | 설명                           |
| :-------- | :------ | :--------------------------- |
| **sub**   | Payload | 사용자 고유 식별자 (User ID)         |
| **idx**   | Payload | 사용자 DB Primary Key           |
| **sid**   | Payload | Redis 세션과 매핑되는 고유 식별자 (UUID) |
| **name**  | Payload | 사용자의 이름                      |

### 4.2 Refresh Token(JWT)
Refresh Token은 Access Token 만료 시 재발급을 위해 사용되는 토큰으로, 클라이언트와 서버 간의 장기 인증 상태 유지를 담당합니다. Redis가 정상 동작 중이며, Refresh token과 매핑된 서버 세션이 유효한 경우에만 재발급이 허용됩니다. 이를 통해 탈취된 Refresh Token 단독 사용으로 인한 무제한 접근을 방지하고, 서버 주도의 세션 생명주기 제어가 가능하도록 설계되었습니다. 

### 4.3 Redis Session
Redis Session은 서버가 관리하며 실질적인 로그인 상태와 권한 정보를 담고 있습니다. 로그아웃 시 해당 데이터가 삭제됩니다.  Access Token이 존재하더라도 Redis Session이 만료되거나 삭제된 경우  
인증은 실패 처리됩니다.

| 항목             | 구분    | 설명                                            |
| :------------- | :---- | :-------------------------------------------- |
| **Key Format** | 키 구조  | `sess:{sid}`                                  |
| **Value**      | 데이터   | 사용자 Context 정보 (JSON 직렬화)                     |
| **TTL**        | 만료 정책 | 기본 1시간 (Sliding / Idle Timeout)               |
| **Strategy**   | 관리 전략 | API 요청 시마다 TTL 갱신 (Touch), 로그아웃 시 즉시 삭제 (Del) |

### 4.4 세션 인덱싱 구조
본 시스템은 다중 로그인 환경을 지원하기 위해,
Redis에 사용자 단위로 활성 세션을 추적할 수 있는 인덱스 구조를 함께 관리합니다.

이를 통해 특정 사용자의 모든 로그인 세션을 서버 측에서 식별하고,
강제 로그아웃, 권한 변경, 계정 잠금과 같은 운영 이벤트 발생 시
해당 사용자의 모든 세션을 즉시 무효화할 수 있습니다.

| 항목 | 구분 | 설명 |
| :-- | :-- | :-- |
| **Key Format** | 키 구조 | `user:{userId}:sessions` |
| **Type** | 자료형 | SET |
| **Value** | 멤버 | 활성 세션의 SID 목록 |
| **TTL** | 만료 정책 | 세션 TTL과 동일 (Sliding Window) |

로그인 시 새로운 SID는 해당 SET에 추가되며,
API 요청이 정상적으로 인증될 경우 세션 본문(`sess:{sid}`)과 함께 TTL이 갱신됩니다.

강제 로그아웃 또는 권한 변경 발생 시,
해당 사용자에 매핑된 모든 SID를 조회하여 세션 데이터를 삭제함으로써
다음 요청 시 인증 실패를 유도합니다.

### 4.5 인증 필터 / 인터셉터
인증 필터는 Spring Security Filter Chain에서 동작하며,  
모든 요청에 대해 다음 순서로 인증을 수행합니다.

1. 요청 헤더 또는 쿠키에서 토큰 추출
    
2. JWT 서명 및 만료 시간 검증
    
3. Redis Session 존재 여부 확인
    
4. 인증 성공 시 SecurityContext에 인증 정보 설정

Redis 상태에 따라 정상 모드 또는 장애 대응 모드로 분기하여  
보안성과 가용성 간의 균형을 유지합니다.
또한 토큰 블랙리스트 대신 Redis 세션 무효화를 기준으로 인증을 판단하여, 추가적인 블랙리스트 저장 비용과 조회 비용을 최소화하였습니다.
### 4.6 권한(인가) 레이어
인가 처리는 인증 이후 단계에서 수행되며,  
Spring Security의 메서드 기반 권한 검사를 중심으로 구성됩니다.

- 권한 및 세부 권한 정보는 DB 및 캐시를 통해 관리
    
- `@PreAuthorize`를 사용하여 컨트롤러/서비스 레벨 접근 제어 수행
    
- PermissionService를 통해 권한 조회 및 캐시 기반 검증 로직을 공통화

이를 통해 인증(AuthN)과 인가(AuthZ)를 명확히 분리하고,  
권한 변경 시 서버 주도의 즉각적인 접근 제어가 가능하도록 설계되었습니다.

---
## 5. 라이플사이클별 흐름
본 장에서는 인증 시스템의 주요 흐름을 로그인, 요청 처리, 토큰 재발급, 로그아웃, 강제 만료 단계로 나누어 설명합니다.  
세션의 최종 만료 기준은 **Redis Session(SID TTL)** 이며, 클라이언트 측 자동 로그아웃 동기화를 위해 세션 만료 시각을 함께 제공합니다.

### 5.1 로그인

1. 사용자는 ID/PW로 로그인을 요청합니다.
    
    - 계정 존재 여부 및 상태를 함께 확인합니다.
        
2. 인증 성공 시 `authService.login()`을 통해 다음 값을 발급합니다.
    
    - Access Token
        
    - Refresh Token
        
    - Session ID(SID)
        
3. Access Token을 HttpOnly 쿠키로 설정합니다.
    
    - 쿠키 TTL은 `accessTokenValidity` 설정 값을 사용합니다.
        
4. Refresh Token을 HttpOnly 쿠키로 설정합니다.
    
    - 쿠키 TTL은 `refreshTokenValidity` 설정 값을 사용합니다.
        
5. Redis Session 생성 시점 기준으로 세션 만료 시각(SessionExp)을 계산합니다.
    
    - `현재 시각 + sessionTtlSeconds`
        
6. SessionExp 값은 다음 두 위치로 전달합니다.
    
    - 쿠키 (`HttpOnly=false`, 프론트 타이머 설정 목적)
        
    - 응답 헤더 (`X-SESSION-EXPIRES`)
        
7. Access Token의 Claims를 기반으로 사용자 정보 DTO를 생성하여 응답합니다.
    

※ `/auth/*` 경로는 인증 필터 검증 대상에서 제외되며,  
CSRF는 Security 설정에서 로그인 엔드포인트 예외 처리합니다.

### 5.2 요청(Request) 처리

1. 클라이언트는 API 요청 시 Access Token 쿠키를 포함하여 요청합니다.
    
2. 인증 필터는 다음 순서로 검증을 수행합니다.
    
    1. 토큰 추출
        
    2. JWT 서명 검증
        
    3. JWT 만료(exp) 검증
        
3. 검증 성공 시 Payload의 SID를 기준으로 Redis Session(`sess:{sid}`)을 조회합니다.
    
4. Redis Session이 존재하는 경우
    
    - 세션 TTL을 갱신합니다. (기본 1시간)
        
    - SecurityContext에 인증 정보를 설정합니다.
        
5. Redis Session이 없거나 만료된 경우
    
    - Access Token이 유효하더라도 인증 실패로 처리합니다.

### 5.3 토큰 재발급(Refresh)

Access Token 만료 시 Refresh Token을 통해 재발급을 요청합니다.

재발급은 다음 조건을 모두 만족하는 경우에만 허용됩니다.

- Redis가 정상 상태일 것
    
- Refresh Token이 유효할 것
    
- Refresh Token과 매핑된 Redis Session이 존재할 것

재발급 성공 시

- 새로운 Access Token을 발급합니다.
    
- Redis Session TTL을 갱신합니다.
    
- SessionExp를 다시 계산하여 쿠키/헤더로 전달합니다.

재발급 거부 처리

- Refresh Token 만료 또는 불일치 → 401
    
- Redis Session 미존재 → 401
    
- 계정 상태 변경(정지/탈퇴) → 403

Refresh Token Rotation은 적용하지 않았으며,  
세션 무효화를 기준으로 재사용을 제어합니다.

### 5.4 로그아웃(Logout)

1. 로그아웃 요청 시 Access Token에서 SID를 추출합니다.
    
2. Redis에서 다음 데이터를 삭제합니다.
    
    - `sess:{sid}`
        
    - `user:{userId}:sessions`에서 해당 SID 제거
        
    - Refresh Token 관련 데이터
        
3. 클라이언트 쿠키(Access/Refresh/SessionExp)를 만료 처리합니다.

이후 요청은 Redis Session 미존재로 인해 인증 실패 처리됩니다.

### 5.5 강제 만료(관리자 처리)

다음 이벤트 발생 시 강제 만료를 수행합니다.

- 비밀번호 변경
    
- 권한 변경
    
- 계정 정지
    
- 계정 탈퇴

처리 절차는 다음과 같습니다.

1. `user:{userId}:sessions`에서 활성 SID 목록을 조회합니다.
    
2. 조회된 모든 SID에 대해 Redis Session(`sess:{sid}`)을 삭제합니다.
    
3. 사용자 세션 인덱스를 제거합니다.

해당 사용자가 보유한 모든 Access Token은  
다음 요청 시 즉시 무효화됩니다.

---
## 6. 보안 정책
인증 아키텍처 전반에 적용된 보안 정책과 설계 의도를 기술하였습니다.  
JWT와 Redis 기반 세션을 결합한 구조를 채택하고 있으므로, 토큰 전달 방식, 쿠키 보안 속성, 서명 키 관리, 그리고 인증 토큰 탈취 시나리오를 중심으로 보안 정책을 구성하였습니다.

### 6.1 쿠키 정책
본 시스템에서 Access Token과 Refresh Token은 HTTP 쿠키를 통해 클라이언트와 서버 간에 전달됩니다. 인증 토큰은 브라우저 저장소(LocalStorage, SessionStorage 등)에 저장하지 않으며, 쿠키 기반 전달 방식을 사용합니다.

Access Token과 Refresh Token에는 HttpOnly 속성이 적용됩니다. 이로 인해 브라우저의 JavaScript 실행 환경에서는 토큰 값에 직접 접근할 수 없으며, XSS 공격 발생 시 인증 토큰 탈취를 방지합니다. 클라이언트는 토큰의 내부 값을 인식하지 않으며, 모든 인증 판단은 서버 측에서 수행됩니다.

세션 만료 시각(SessionExp)은 프론트엔드의 자동 로그아웃 처리를 위한 용도로 제공됩니다. 해당 값은 인증 판단에 사용되지 않으며, Redis Session의 TTL을 기준으로 최종 인증 여부가 결정됩니다. SessionExp 값은 HttpOnly=false 쿠키 및 응답 헤더로 전달되며, 클라이언트 측에서 조작되더라도 서버 인증 결과에는 영향을 미치지 않습니다. Redis Session이 만료된 경우 Access Token이 존재하더라도 인증은 실패 처리됩니다.

모든 인증 관련 쿠키에는 Secure 속성이 적용됩니다. 이로 인해 HTTPS 연결에서만 쿠키가 전송되며, 네트워크 구간에서의 인증 정보 노출을 방지합니다. 본 시스템은 HTTPS 사용을 전제로 동작합니다.

SameSite 정책은 Lax 모드로 설정됩니다. 동일 사이트 요청에서는 쿠키가 정상적으로 전송되며, 외부 사이트에서 유도된 요청에 대해서는 쿠키 전송이 제한됩니다. 이를 통해 CSRF 공격 가능성을 완화하면서 SSR과 CSR이 혼합된 구조에서 인증 쿠키 전달을 안정적으로 유지합니다.

### 6.2 JWT 서명 키 및 알고리즘
본 시스템에서 발급되는 Access Token과 Refresh Token은 대칭키 기반 서명 알고리즘을 사용하여 서명됩니다. 현재 구현에서는 HS256 알고리즘을 사용합니다.

JWT 서명 키는 애플리케이션 설정을 통해 주입되며, 설정 파일 또는 환경 변수를 통해 관리됩니다. 서명 키는 서버 내부에서만 사용되며, 외부에 노출되지 않습니다.

대칭키 기반 구조의 특성상 서명 키가 변경될 경우, 기존 키로 발급된 모든 JWT는 검증에 실패합니다. 본 시스템에서는 키 변경 시 기존 토큰이 모두 무효화되는 구조를 허용합니다. 다중 키 검증이나 키 롤링 방식은 현재 적용하지 않았습니다.

### 6.3 기타 보안 고려 사항
본 시스템은 인증 토큰을 쿠키 기반으로 전달하므로 CSRF 공격 가능성을 고려합니다. SameSite 정책을 적용하여 크로스 사이트 요청에서의 쿠키 자동 전송을 제한합니다. 로그인 엔드포인트(`/auth/login`)는 Spring Security 설정에서 CSRF 검증 예외로 처리됩니다.

인증 쿠키에는 Secure 속성이 적용되므로, HTTPS 환경이 아닌 경우 인증 쿠키는 전송되지 않습니다. 이는 의도된 보안 정책이며, 운영 환경에서는 HTTPS 사용을 필수로 합니다.

Access Token 또는 Refresh Token이 탈취되더라도, Redis Session이 만료되거나 삭제된 경우 인증은 실패 처리됩니다. 또한 관리자에 의한 계정 상태 변경, 권한 변경, 강제 로그아웃 시 Redis Session을 기준으로 즉시 인증을 차단합니다. 이를 통해 토큰 단독 탈취로 인한 장기 인증 유지 가능성을 제한합니다.

---
## 7. 장애·예외 상황 & 대응
인증 시스템 운용 중 발생할 수 있는 주요 장애 및 예외 상황과, 이에 대한 시스템의 대응 방식을 설명합니다.  보안성과 가용성 간의 균형을 목표로 하였으며, 장애 상황에서도 서비스 전체 중단을 최소화하는 방향으로 구성되었습니다.
### 7.1 Redis 장애 시
Redis는 세션 상태 및 권한 생명주기를 관리하는 핵심 구성 요소입니다.  다만 Redis 장애로 인해 전체 인증 기능이 중단되는 상황을 방지하기 위해, 본 시스템은 Redis 장애 상황을 고려한 우아한 강등(Graceful Degradation) 방식으로 설계되었습니다.

Redis가 정상적으로 동작하는 경우에는 Redis Session을 기준으로 인증 및 인가를 수행합니다.  반면 Redis 접속 불가 또는 타임아웃이 발생한 경우, 시스템은 장애 대응 모드로 전환됩니다.

장애 대응 모드에서는 서버 측 Redis Session 검증을 수행하지 않고,  기존에 발급된 Access Token의 서명 및 만료 시간(exp) 검증만을 기준으로 인증을 수행합니다.  이를 통해 Redis 장애 상황에서도 기존 로그인 사용자의 기본적인 서비스 접근은 유지됩니다.

다만 Redis 장애 상태에서는 권한 정보를 Redis에서 조회할 수 없으므로,  인가 단계에서는 모든 사용자를 **최소 권한**으로 강등하여 처리합니다.  관리자 권한, 특수 권한, 민감 기능 접근은 모두 제한됩니다.

Redis 장애가 해소되면,  인증 및 인가 로직은 자동으로 정상 모드로 복귀하며  다시 Redis Session 및 권한 정보를 기준으로 동작합니다.

### 7.2 토큰 만료 시
Access Token이 만료된 경우, 서버는 인증 실패로 처리하며 HTTP 401 상태 코드를 반환합니다.  클라이언트는 해당 응답을 기준으로 Refresh Token을 이용한 재발급을 시도합니다.

Redis Session이 만료되었거나 삭제된 경우에는  Access Token이 유효하더라도 인증 실패로 처리됩니다.  이 경우에도 서버는 HTTP 401 상태 코드를 반환합니다.

프론트엔드에서는 로그인 시 전달된 SessionExp 값을 기준으로  클라이언트 측 자동 로그아웃 타이머를 설정합니다.  이를 통해 사용자는 서버 응답 이전에 세션 만료를 인지할 수 있으며,  세션 만료 시 즉시 로그인 화면으로 전환됩니다. 이와 같은 방식으로 서버 인증 상태와 클라이언트 UX 간의 시간 차이를 최소화하였습니다.

### 7.3 토큰 위변조 탐지 시
JWT 서명 검증 실패 또는 구조 오류가 발생한 경우,  해당 요청은 인증 실패로 처리되며 HTTP 401 상태 코드를 반환합니다. 토큰 위변조가 의심되는 경우,  인증 필터 단계에서 예외를 발생시키고 관련 로그를 기록합니다.

로그에는 다음 정보가 포함됩니다.

- 요청 시각
    
- 요청 URI
    
- 토큰 검증 실패 사유
    
- 사용자 식별 정보(가능한 경우)

현재 설계에서는 토큰 위변조에 대한 별도의 실시간 알림 또는 자동 차단 기능은 적용하지 않았습니다.  다만 로그를 기반으로 운영 환경에서의 모니터링 및 사후 분석이 가능하도록 구성하였습니다.

---
## 8. 트레이드오프 / 한계
인증 아키텍처의 장점과 한계, 그리고 향후 개선 가능성을 정리합니다.

### 8.1 전통적인 세션 방식 대비 장점
본 구조는 전통적인 서버 세션 기반 인증 방식과 비교하여 다음과 같은 장점을 가집니다.

- JWT를 사용함으로써 인증 정보 전달이 Stateless하게 이루어집니다.
    
- 다중 서버 환경에서 세션 동기화 문제 없이 확장이 가능합니다.
    
- Redis를 활용하여 서버 주도의 세션 제어가 가능합니다.
    
- 강제 로그아웃, 권한 변경 즉시 반영 등 엔터프라이즈 환경에서 요구되는 기능을 구현할 수 있습니다.

### 8.2 전통적인 세션 방식 대비 단점
반면 다음과 같은 단점도 존재합니다.

- Redis라는 외부 인프라에 대한 의존성이 발생합니다.
    
- 인증 흐름이 단순한 세션 방식에 비해 복잡합니다.
    
- 장애 대응 모드에서는 보안 수준이 일시적으로 낮아질 수 있습니다.




